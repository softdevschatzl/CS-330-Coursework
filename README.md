# CS-330-Coursework

## 1. How do I approach designing software?
### What new design skills has your work helped you craft?
For starters, this work has helped me fine-tune my attention to detail. In my personal and professional work, I've always dealt with frameworks
that allow my to abstract away much of the happenings under the hood and allow me to focus on the bigger picture. With OpenGL, I've been thrust 
back into a world where I need to be attentive of every little detail, every little float value, and this helps with keeping me on my toes.
### What design process did you follow for your project work?
My design process throughout my work for this course mostly follow some simple steps.
- Planning: Initial planning involved outlining the core features and how the interact with the game/scene.
- Prototyping: Early versions of my scenes were developed to test basic elements of the scene, lighting, texturing etc.
- Iteration: The design was refined iteratively, taking things one step at a time so as to not lose sight of some smaller, yet no less significant features.
- Finalization: The final design integrated all the refined components into a cohesive system, ensuring all functionalities worked seamlessly together.
### How could tactics from your design approach be applied in future work?
There are many tactics from my design approach that could be applied in future work. For instance, iterative refinement is a huge step in my development process 
and design approach that keeps things bite-sized and prevents me from getting overwhelmed by continuously impriving the design based on testing and feedback.
Modularity also allows me to enhance reusability of my code and easier to maintain as well.

## 2. How do I approach developing programs?
### What new development strategies did you use while working on your 3D scene?
There are many new development strategies I used and improved upon while working on my 3D scene:
- Planning: Start with a clear plan outlining the program's objectives, requirements, and a roadmap for development.
- Implementation: Develop the program incrementally, starting with core functionalities and gradually adding more features.
- Testing: Regularly test the program to identify and fix bugs, ensuring each component works correctly.
- Documentation: Maintain thorough documentation to facilitate understanding and future maintenance.
### How did iteration factor into your development?
Iteration played a very impactful role into my development, mostly through CI/CD practices. I continuously improved upon each iteration, improving lighting,
textures, enhancing the user experience, and creating true to life scenes.
### How has your approach to developing code evolved throughout the milestones, which led you to the projectâ€™s completion?
My approach had evolved mostly through the persepctives on my work. Starting off, I focused more on core functionalities, and ensuring basic interactions worked
as they should, then later on I began introducing more complex features, while incorporating feedback. Finally, in the final stages I was more focused on fine-tuning
my scene to make sure everything fit together well.

## 3. How can computer science help me in reaching my goals?
### How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future educational pathway?
Computational graphics and visualizations gives me a lot of experience that I will use throughout my educational and professional pathway. With an enhanced
ability to problem solve, having to use C++ and it's lack of garbage collection has made me seek new avenues for debugging and getting a closer look 
at how everything works when it comes to coding.
### How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future professional pathway?
In my professional pathway, this gives me more technical expertise especially in regards to lower level languages like C++ allowing me to see deeper into
the code and compilation process to get a more in-depth feel for computing in general.
